<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>LineFlow Creator - Offset Zentangle</title>
    <script src="https://unpkg.com/paper@0.12.15/dist/paper-full.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #tools { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 6px; z-index: 10; }
        #tools * { margin: 4px; font-size: 14px; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
<div id="tools">
    <button onclick="undo()">Voltar</button>
    <select id="thickness" onchange="changeThickness()">
        <option value="1">1px</option>
        <option value="2" selected>2px</option>
        <option value="3">3px</option>
        <option value="4">4px</option>
        <option value="5">5px</option>
    </select>
    <input type="number" id="spacing" value="20" min="1" max="100" title="Espaçamento (px)" onchange="updateSpacing()">
    <input type="color" id="colorPicker" value="#800080" title="Cor do traço">
    <input type="color" id="bgPicker" value="#ffffff" onchange="changeBG()" title="Cor do fundo">
    <button id="editBtn" onclick="toggleEdit()">Editar</button>
    <button onclick="duplicateMaster()">Duplicar (Cmd+J)</button>
    <button onclick="exportPNG()">Exportar PNG</button>
    <button onclick="exportPDF()">Exportar PDF</button>
</div>
<canvas id="myCanvas" resize></canvas>
<script>
    paper.setup('myCanvas');
    const canvasElem = document.getElementById('myCanvas');
    const thickness = document.getElementById('thickness');
    const spacingInput = document.getElementById('spacing');
    const colorPicker = document.getElementById('colorPicker');
    let strokes = [];
    let isDrawing = false;
    let editMode = false;
    let isCmd = false;
    const nClones = 5;

    document.addEventListener('keydown', e => {
        if (e.metaKey) isCmd = true;
        if (isCmd && e.key.toLowerCase() === 'j') { duplicateMaster(); e.preventDefault(); }
        if (isCmd && e.key.toLowerCase() === 'z') { undo(); e.preventDefault(); }
    });
    document.addEventListener('keyup', e => { if (!e.metaKey) isCmd = false; });

    function toggleEdit() {
        editMode = !editMode;
        document.getElementById('editBtn').innerText = editMode ? 'Fechar Ed.' : 'Editar';
        if (!editMode) paper.project.deselectAll();
    }

    function onMouseDown(event) {
        if (editMode) {
            paper.project.deselectAll();
            const hit = paper.project.hitTest(event.point, { segments: true, stroke: true, tolerance: 10 });
            if (hit && hit.item) hit.item.fullySelected = true;
            return;
        }
        // iniciar novo stroke
        const master = new paper.Path({
            strokeColor: colorPicker.value,
            strokeWidth: parseInt(thickness.value),
            fullySelected: false
        });
        strokes.push({ master: master, clones: [] });
        isDrawing = true;
    }

    function onMouseDrag(event) {
        if (!isDrawing || editMode) return;
        const current = strokes[strokes.length - 1];
        current.master.add(event.point);
        drawClones(current);
    }

    function onMouseUp(event) {
        if (!isDrawing || editMode) return;
        isDrawing = false;
        const current = strokes[strokes.length - 1];
        current.master.simplify(4);
        current.master.smooth({ type: 'continuous' });
        drawClones(current);
    }

    function drawClones(strokeItem) {
        // remove clones deste stroke
        strokeItem.clones.forEach(c => c.remove());
        strokeItem.clones = [];
        const masterPath = strokeItem.master;
        if (masterPath.segments.length < 2) return;
        const length = masterPath.length;
        const offsetMax = parseInt(spacingInput.value);
        for (let i = 1; i <= nClones; i++) {
            const clone = masterPath.clone();
            clone.strokeColor = masterPath.strokeColor;
            clone.strokeWidth = masterPath.strokeWidth;
            clone.segments.forEach((seg, idx) => {
                const loc = masterPath.getLocationOf(seg.point);
                const t = loc.offset / length;
                const taper = Math.sin(Math.PI * t);
                const normal = masterPath.getNormalAt(loc.offset).normalize();
                seg.point = seg.point.add(normal.multiply(offsetMax * (i/nClones) * taper));
            });
            strokeItem.clones.push(clone);
        }
    }

    function undo() { paper.project.undo(); }

    function changeBG() { canvasElem.style.backgroundColor = bgPicker.value; }

    function updateSpacing() {
        // redesenha clones de todos strokes
        strokes.forEach(drawClones);
    }

    function duplicateMaster() {
        const current = strokes[strokes.length - 1];
        if (!current) return;
        const copy = current.master.clone();
        copy.strokeColor = current.master.strokeColor;
        copy.strokeWidth = current.master.strokeWidth;
    }

    async function exportPNG() {
        const dataURL = canvasElem.toDataURL('image/png');
        const link = document.createElement('a'); link.download = 'zentangle-offset.png'; link.href = dataURL; link.click();
    }

    async function exportPDF() {
        const canvasImg = await html2canvas(canvasElem);
        const imgData = canvasImg.toDataURL('image/png');
        const pdf = new jspdf.jsPDF({ orientation:'landscape', unit:'px', format:[canvasElem.width, canvasElem.height] });
        pdf.addImage(imgData,'PNG',0,0,canvasElem.width,canvasElem.height); pdf.save('zentangle-offset.pdf');
    }

    paper.view.onMouseDown = onMouseDown;
    paper.view.onMouseDrag = onMouseDrag;
    paper.view.onMouseUp   = onMouseUp;
</script>
</body>
</html>
